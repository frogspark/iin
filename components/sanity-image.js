import Image from 'next/image';
import sanity from '@/services/sanity';
import { useState } from 'react';
import { useNextSanityImage } from 'next-sanity-image';

export default function SanityImage({ image, className, alt, priority, widthOverride, quality, focalPoint, sizes }) {
  // Guard clause: If there's no image prop at all, render nothing.
  if (!image) {
    return null;
  }

  // Handle the Vimeo case first, as it's a completely different render path.
  if (image.vimeoVideo) {
    return (
      <figure className={`image bg-black/20 ${className} cover-image absolute inset-0 w-full h-full object-cover object-center`}>
        <video loop={true} autoPlay="autoplay" playsInline={true} muted className={`object-cover object-center w-full h-full absolute inset-0 z-[10]`}>
          <source src={image.vimeoVideo} type="video/mp4" />
          Sorry. Your browser does not support the video tag.
        </video>
        {/* You may want a poster image here as well */}
      </figure>
    );
  }

  // --- Start of Corrected Image Logic ---

  // 1. All hooks are now called unconditionally at the top level.
  const [imageIsLoaded, setImageIsLoaded] = useState(false);
  
  const myCustomImageBuilder = (imageUrlBuilder, options) => {
    return imageUrlBuilder
      .width((widthOverride || options.width) || Math.min(widthOverride || options.originalImageDimensions.width, 800))
      .quality(quality || 75)
      .fit('clip');
  };

  // 2. Call the hook unconditionally.
  // We pass the 'image' object ONLY if it's a valid Sanity asset that needs processing.
  // Otherwise, we pass `null`, and the hook will return `null`.
  const imageProps = useNextSanityImage(
    sanity.config,
    (image?._type === 'image' && image.asset) ? image : null,
    { imageBuilder: myCustomImageBuilder }
  );

  // 3. Determine the final `src` and `loader` for the <Image> component.
  // Priority is given to the props generated by the hook.
  // If the hook didn't run (because it received null), we check if `image` is a string.
  const src = imageProps?.src || (typeof image === 'string' ? image : null);
  const loader = imageProps?.loader; // Use the custom loader ONLY if the hook generated it.

  // 4. Final guard clause: If we couldn't determine a valid `src`, don't render.
  if (!src) {
    console.warn('SanityImage: Could not determine a valid image source.', { imageProp: image });
    return null;
  }

  // --- Alt Text & Style Logic (Simplified) ---
  const altText = alt || image.alt || image.asset?.altText || 'Missing Image Description';
  const style = {};
  if (focalPoint?.x && focalPoint?.y) {
    style.objectPosition = `${focalPoint.x * 100}% ${focalPoint.y * 100}%`;
  }

  // --- Unified Return for the Image ---
  return (
    <figure className={`image bg-black/20 ${className} cover-image absolute inset-0 w-full h-full object-cover object-center`}>
      <Image
        src={src}
        loader={loader} // This will be `undefined` if not provided by the hook, which is correct.
        className={`absolute inset-0 w-full h-full object-center object-cover will-change-transform transition-all ease-in-out duration-[1500ms] ${imageIsLoaded ? 'scale-1 opacity-100' : 'scale-[1.05] opacity-0'}`}
        priority={priority}
        sizes={sizes || `(max-width: 1024px) 100vw, 90vw`}
        fill
        quality={quality || 75}
        alt={altText}
        style={style}
        onLoad={event => {
          const target = event.target;
          if (target.src.indexOf('data:image/gif;base64') < 0) {
            setImageIsLoaded(true)
          }
        }}
      />
    </figure>
  );
}
